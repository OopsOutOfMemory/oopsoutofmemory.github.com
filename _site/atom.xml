<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>盛利的博客</title>
 <link href="http://oopsoutofmemory.github.io/atom.xml" rel="self"/>
 <link href="http://oopsoutofmemory.github.io/"/>
 <updated>2014-11-13T18:16:42+08:00</updated>
 <id>http://oopsoutofmemory.github.io</id>
 <author>
   <name>OopsOutOfMemory</name>
   <email></email>
 </author>

 
 <entry>
   <title>Spark Common Issues</title>
   <link href="http://oopsoutofmemory.github.io/blog/Spark-Common-Issues"/>
   <updated>2014-11-13T00:00:00+08:00</updated>
   <id>http://oopsoutofmemory.github.io/blog/Spark-Common-Issues</id>
   <content type="html">&lt;h2&gt;1、WARN TaskSchedulerImpl: Initial job has not accepted any resources; check your cluster ui to ensure that workers are registered and have sufficient memory&lt;/h2&gt;

&lt;p&gt;当前的集群的可用资源不能满足应用程序所请求的资源。&lt;/p&gt;

&lt;p&gt;资源分2类： &lt;code&gt;cores&lt;/code&gt; 和 &lt;code&gt;ram&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cores&lt;/strong&gt;代表对执行可用的&lt;code&gt;executor slots&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ram&lt;/strong&gt;代表每个Worker上被需要的空闲内存来运行你的&lt;code&gt;Application&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;解决方法：
应用不要请求多余空闲可用资源的
关闭掉已经执行结束的Application&lt;/p&gt;

&lt;h2&gt;2、Application isn’t using all of the Cores: How to set the Cores used by a Spark App&lt;/h2&gt;

&lt;p&gt;设置每个App所能获得的core
解决方法：
spark-env.sh里设置spark.deploy.defaultCores
或
spark.cores.max&lt;/p&gt;

&lt;hr&gt;

&lt;h2&gt;3、Spark Executor OOM: How to set Memory Parameters on Spark&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;OOM是内存里堆的东西太多了
增加job的并行度，即增加job的partition数量，把大数据集切分成更小的数据，可以减少一次性load到内存中的数据量。InputFomart， getSplit来确定。&lt;/li&gt;
&lt;li&gt;spark.storage.memoryFraction
管理executor中RDD和运行任务时的内存比例，如果shuffle比较小，只需要一点点shuffle memory，那么就调大这个比例。默认是0.6。不能比老年代还要大。大了就是浪费。&lt;/li&gt;
&lt;li&gt;spark.executor.memory如果还是不行，那么就要加Executor的内存了，改完executor内存后，这个需要重启。
***&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;4、Shark Server/ Long Running Application Metadata Cleanup&lt;/h2&gt;

&lt;p&gt;Spark程序的元数据是会往内存中无限存储的。spark.cleaner.ttl来防止OOM，主要出现在Spark Steaming和Shark Server里。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SPARK_JAVA_OPTS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;-Dspark.kryoserializer.buffer.mb=10 -Dspark.cleaner.ttl=43200&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h2&gt;5、Class Not Found: Classpath Issues&lt;/h2&gt;

&lt;p&gt;问题1、缺少jar，不在classpath里。
问题2、jar包冲突，同一个jar不同版本。&lt;/p&gt;

&lt;p&gt;解决1：
将所有依赖jar都打入到一个fatJar包里，然后手动设置依赖到指定每台机器的DIR。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-scala&quot; data-lang=&quot;scala&quot;&gt;&lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conf&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SparkConf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setAppName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setJars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Seq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getProperty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;user.dir&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;/target/scala-2.10/sparktest.jar&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决2：
把所需要的依赖jar包都放到default classpath里，分发到各个worker node上。&lt;/p&gt;

&lt;h2&gt;6、关于性能优化：&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;第一个是sort-based shuffle。这个功能大大的减少了超大规模作业在shuffle方面的内存占用量，使得我们可以用更多的内存去排序。&lt;/li&gt;
&lt;li&gt;第二个是新的基于Netty的网络模块取代了原有的NIO网络模块。这个新的模块提高了网络传输的性能，并且脱离JVM的GC自己管理内存，降低了GC频率。&lt;/li&gt;
&lt;li&gt;第三个是一个独立于Spark executor的external shuffle service。这样子executor在GC的时候其他节点还可以通过这个service来抓取shuffle数据，所以网络传输本身不受到GC的影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;过去一些的参赛系统软件方面的处理都没有能力达到硬件的瓶颈，甚至对硬件的利用率还不到10%。而这次我们的参赛系统在map期间用满了3GB/s的硬盘带宽，达到了这些虚拟机上八块SSD的瓶颈，在reduce期间网络利用率到了1.1GB/s，接近物理极限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;h2&gt;参考文献：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.datastax.com/dev/blog/common-spark-troubleshooting&quot; target=&quot;_blank&quot;&gt;http://www.datastax.com/dev/blog/common-spark-troubleshooting&lt;/a&gt;
&lt;a href=&quot;http://www.csdn.net/article/2014-11-06/2822505&quot; target=&quot;_blank&quot;&gt;http://www.csdn.net/article/2014-11-06/2822505&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
